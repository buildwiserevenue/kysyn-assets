name: Resilient Build 100+ Grammars
on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'

permissions:
  contents: write

jobs:
  build-all-wasm:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node & Emscripten
        uses: actions/setup-node@v4
        with: { node-version: '20' }
      
      - name: Install Tree-sitter CLI
        run: npm install -g tree-sitter-cli

      - name: Setup Emscripten
        uses: mymindstorm/setup-emsdk@v14
        with: { version: 3.1.64 }

      # --- NOVIT√Ä: CACHE PER NON RISCARICARE OGNI VOLTA ---
      - name: Cache Tree-sitter WASI SDK
        uses: actions/cache@v4
        with:
          path: /home/runner/.cache/tree-sitter
          key: tree-sitter-wasi-v29

      - name: Build Loop
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p grammars
          [ -f versions.json ] || echo "{}" > versions.json
          sed -i 's/\r//' languages.txt

          grep -v '^#' languages.txt | while read -r repo_entry; do
            [ -z "$repo_entry" ] && continue
            
            if [[ "$repo_entry" == *":"* ]]; then
              base_repo="${repo_entry%%:*}"
              subdir="${repo_entry##*:}"
              lang_name="$subdir"
            else
              base_repo="$repo_entry"
              subdir=""
              lang_name=$(basename "$base_repo" | sed 's/tree-sitter-//')
            fi

            echo "--------------------------------------------"
            echo "üîç Checking $lang_name ($base_repo)..."

            # Protezione 404: se gh api fallisce, REMOTE_SHA diventa "ERROR"
            REMOTE_SHA=$(gh api repos/$base_repo/commits/HEAD --template '{{.sha}}' 2>/dev/null || echo "ERROR")
            
            if [ "$REMOTE_SHA" == "ERROR" ]; then
              echo "‚ö†Ô∏è Repo non trovato o errore API per $base_repo. Salto."
              continue
            fi

            LOCAL_SHA=$(jq -r ".\"$lang_name\"" versions.json)

            if [ "$REMOTE_SHA" == "$LOCAL_SHA" ] && [ -f "grammars/$lang_name.wasm" ]; then
              echo "‚è≠Ô∏è $lang_name gi√† aggiornato."
              continue
            fi

            echo "üèóÔ∏è Building $lang_name..."
            rm -rf temp_repo
            if ! gh repo clone "$base_repo" temp_repo -- --depth 1 2>/dev/null; then
              echo "‚ùå Clone failed per $base_repo"
              continue
            fi
            
            cd temp_repo
            [ -n "$subdir" ] && cd "$subdir"
            
            if tree-sitter build --wasm; then
              generated_wasm=$(find . -maxdepth 1 -name "*.wasm" | head -n 1)
              if [ -n "$generated_wasm" ]; then
                mv "$generated_wasm" "$GITHUB_WORKSPACE/grammars/$lang_name.wasm"
                cd "$GITHUB_WORKSPACE"
                # Aggiorna il JSON immediatamente in memoria
                jq ".\"$lang_name\" = \"$REMOTE_SHA\"" versions.json > tmp.json && mv tmp.json versions.json
                echo "‚úÖ Success: $lang_name"
              fi
            else
              echo "‚ùå Build failed per $lang_name"
            fi
            
            cd "$GITHUB_WORKSPACE"
            rm -rf temp_repo
            sleep 2
          done

      # --- NOVIT√Ä: SALVA ANCHE SE CI SONO STATI ERRORI PARZIALI ---
      - name: Commit Results
        if: always() # Esegue questo step anche se il loop ha avuto dei "continue" o errori
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ü§ñ Smart Update: Progressi build WASM"
          file_pattern: 'grammars/*.wasm versions.json'
